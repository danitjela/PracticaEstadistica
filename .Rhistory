labs(title = "Distribución de las puntuaciones",
x = "Puntuación",
y = "Frecuencia")
lab |> select(reviewScore) |> descr() |> kable(digits = 2)
# Calcular las frecuencias absolutas y relativas
tabla_frecuencias_publisherclass <- lab |>
count(publisherClass) |>
mutate(f = n / nrow(lab))
# Mostrar la tabla
print(tabla_frecuencias_ordenada3)
lab  |> group_by(publisherClass) |>  summarise(Frequency = n()) |> mutate(Frequency = Frequency/sum(Frequency), publisherClass = reorder(publisherClass, -Frequency)) |> ggplot(aes(x = publisherClass, y = Frequency)) + geom_bar(stat = "identity", aes(fill = Frequency)) + scale_y_continuous(labels = scales::percent) + theme_bw() + labs(title = "Gráfico de barras con frecuencia relativa de PUBLISHERCLASS", x = "Tipo de empresa", y = "Frecuencia relativa") + scale_fill_gradient("Frecuencia", low = "skyblue", high = "#CB0017") + theme(axis.text.x = element_text(angle = 45, hjust = 1))
lab |>
group_by(publisherClass) |>
summarise(Frequency = n()) |>
mutate(publisherClass = reorder(publisherClass, -Frequency)) |>
ggplot(aes(x = publisherClass, y = Frequency)) +
geom_bar(stat = "identity", aes(fill = Frequency)) +
theme_bw() +
labs(title = "Gráfico de barras con frecuencia absoluta de TYPE",
x = "Tipo de casa",
y = "Frecuencia absoluta") +
scale_fill_gradient("Frecuencia", low = "skyblue", high = "#CB0017") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
table(lab$developers) |>
# Convierte la tabla de frecuencias en un dataframe.
as.data.frame() |>
arrange(desc(Freq)) |>
# Selecciona solo los 10 desarrolladores más frecuentes.
slice(1:10) |>
# Añade una nueva columna 'F' calculando la frecuencia relativa acumulada.
mutate(F = cumsum(Freq)/sum(Freq)) |>
# Convierte el dataframe resultante en una tabla 'gt' para formateo y estilización avanzados.
gt() |>
# Añade un título en cursiva y negrita a la tabla de frecuencias
tab_header(
title = md("**_Los 10 desarrolladores más frecuentes_**")
) |>
# Cambia las etiquetas de las columnas a notación matemática.
cols_label(Var1 = "Desarrollador",  # Cambia 'Var1' a 'Desarrollador' (nombres individuales).
Freq = "Frecuencia",  # Cambia 'Freq' a 'Frecuencia' (representando la frecuencia de cada valor).
F = "Frecuencia relativa acumulada") |>  # Cambia 'F' al nombre completo en español.
# Formatea los números a mostrar cuatro decimales.
fmt_number(3, decimals = 4) |>
# Aplica un estilo de texto en negrita a la fila de encabezado de la tabla.
tab_style(style = list(
cell_text(weight = "bold")),
locations = cells_column_labels())
# 'lab |> ggplot(aes(x= "ph", y = ph)) +' inicia una visualización ggplot2 usando el dataframe 'lab'.
lab |>
ggplot(aes(x= "ph", y = ph)) +  # Configura las estéticas del gráfico.
# 'aes()' define cómo se asignarán variables a estéticas visuales en el gráfico.
# 'x= "ph"' establece una constante para el eje x.
# 'y = ph' asigna la columna 'ph' del dataframe 'lab' al eje y.
# 'geom_boxplot()' añade un gráfico de cajas al gráfico.
# Esta función crea un diagrama de cajas que es útil para visualizar la distribución de una variable cuantitativa.
geom_boxplot()+
# 'theme_bw()' aplica un tema en blanco y negro para la visualización.
# Este tema proporciona un fondo claro y líneas oscuras, lo que resulta en un gráfico con alto contraste y fácil de leer.
theme_bw()
lab |> select(where(is.numeric), -codigo) |>  # Selecciona solo las variables numéricas, excluyendo 'codigo'
drop_na() |>  # Elimina filas con valores NA
descr() # 'descr' es la función que se aplica. Calcula estadísticas descriptivas para todas las variables numéricas.
# 'z_ph <- scale(lab$ph)' calcula el puntaje z para la columna 'ph' del dataframe 'lab'.
z_ph <- scale(lab$ph)
# 'scale()' es una función en R que estandariza los datos.
# Resta la media y divide por la desviación estándar, resultando en datos con una media de 0 y una desviación estándar de 1.
# Esto es útil para normalizar datos, especialmente en preparación para ciertos análisis estadísticos.
# 'mean(z_ph)' calcula la media de los puntajes z de 'ph'.
mean(z_ph)
# 'sd(z_ph)' calcula la desviación estándar de los puntajes z de 'ph'.
sd(z_ph)
# Transforma 'lab' creando una nueva columna 'clases_est' que clasifica 'est' en 8 intervalos
lab |>
mutate(clases_est = cut(est, breaks = 8)) |>
# Cuenta la frecuencia de cada clase en 'clases_est'
count(clases_est)
# Utiliza 'knitr::kable' para crear una tabla formateada de la tabla de proporciones de 'imperfecciones'
knitr::kable(
# Calcula la tabla de proporciones para la columna 'imperfecciones' en 'lab'
prop.table(table(lab$imperfecciones)),
# Redondea los números a 4 decimales
digits = 4
)
# Genera un histograma de la columna 'ph' del dataframe 'lab', pero no lo dibuja (plot = FALSE).
# El resultado se guarda en 'histo', que contiene, entre otros, los límites de los intervalos (breaks).
histo <- hist(lab$ph, plot = FALSE)
# Actualiza el dataframe 'lab' mediante 'mutate' para añadir una nueva columna 'clase'.
# 'cut' se utiliza para dividir la columna 'ph' en intervalos basados en los límites encontrados en 'histo$breaks'.
lab <- lab |>
mutate(clase = cut(ph, breaks = histo$breaks))
# Añade un nivel adicional "(6.4,6.45]" a los factores de la columna 'clase'.
# Esto es para incluir valores específicos que no estaban originalmente en los intervalos generados por 'hist' porque su suma es frecuencia es 0.
levels(lab$clase) <- c(levels(lab$clase), "(6.4,6.45]")
# Calcula la tabla de frecuencias para 'lab$clase' y la convierte en un dataframe.
tabla_frecuencias <- as.data.frame(table(lab$clase))
# Añade una columna para la frecuencia relativa (f) y los acumulados (N y F) redondeado a 0.
tabla_frecuencias <- tabla_frecuencias |>
mutate(
f = round(Freq / sum(Freq), 4), # Frecuencia relativa redondeada a cuatro decimales
N = cumsum(Freq),               # Frecuencia acumulada
F = round(cumsum(f), 4)         # Frecuencia relativa acumulada redondeada a cuatro decimales
)
# Usa 'flextable' para crear una tabla flexible a partir de 'tabla_frecuencias'.
flextable(tabla_frecuencias) |>
# Personaliza los encabezados de la tabla.
flextable::set_header_labels(
Var1 = "Clase",
Freq = "n",
f = "Frecuencia Relativa",
N = "Frecuencia Acumulada",
F = "Frecuencia Relativa Acumulada"
)
#Comprobamos que no falte ningún dato
sum(is.na(lab$copiesSold))
sum(is.na(lab$revenue))
#Realizamos el resumen de ambas variables
summary(lab$copiesSold)
summary(lab$revenue)
ggplot(lab, aes(x = copiesSold, y = revenue)) +
geom_jitter(color = "blue", size = 1, width = 0.2, height = 0, alpha = 0.7) +
scale_y_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),
format(x)))
}) +
scale_x_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),
format(x)))
}) +
labs(title = "Relación entre Copias Vendidas y Recaudación",
x = "Copias Vendidas",
y = "Recaudación (en logaritmos)") +
theme_minimal()
correlacion <- cor(lab$copiesSold, lab$revenue, use = "complete.obs")
correlacion_df <- data.frame(Variable1 = "copiesSold",
Variable2 = "revenue",
Correlacion = round(correlacion, 2))
correlacion_df %>%
kable(caption = "Correlación entre las copias vendidas y la recaudación") %>%
kable_styling(full_width = F)
# Ajustar un modelo de regresión lineal
modelo <- lm(revenue ~ copiesSold, data = lab)
# Resumen del modelo
summary(modelo)
ggplot(lab, aes(x = copiesSold, y = revenue)) +
geom_point(size = 2, alpha = 0.7) +  # Puntos del gráfico
geom_smooth(method = "lm", color = "blue") +  # Línea de regresión
scale_x_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),  # Formato en millones
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),  # Formato en miles
format(x)))  # Menos de mil
}) +
scale_y_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),  # Formato en millones
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),  # Formato en miles
format(x)))  # Menos de mil
}) +
labs(title = "Regresión Lineal: Copias Vendidas vs Recaudación",
x = "Copias Vendidas",
y = "Recaudación (en miles de dólares)") +
theme_minimal()
ggplot(lab, aes(x = publisherClass, y = revenue)) +
geom_bar(stat = "summary", fun = "mean", fill = "steelblue") +  # Barras que muestran la media
labs(title = "Recaudación por tipo de empresa",
x = "Tipo de empresa",
y = "Recaudación promedio")
ggplot(lab, aes(x = publisherClass, y = revenue)) +
geom_boxplot(fill = "lightblue", color = "darkblue") +
labs(title = "Distribución de la Recaudación por Tipo de Empresa",
x = "Tipo de Empresa",
y = "Recaudación") +
theme_minimal()
ggplot(lab, aes(x = publisherClass, y = revenue)) +
geom_boxplot(fill = "lightblue", color = "darkblue") +
scale_y_log10() +  # Aplica una escala logarítmica al eje Y
labs(title = "Distribución de la Recaudación por Tipo de Empresa (Escala Logarítmica)",
x = "Tipo de Empresa",
y = "Recaudación (log)") +
theme_minimal()
# Convertir las variables continuas en categorías, con intervalos cerrados a la izquierda y abiertos a la derecha
lab$logrevenue <- log10(lab$revenue)
# Definir los intervalos logarítmicos
# Elige un rango adecuado en la escala logarítmica para crear los intervalos.
lab$revenue_cat_log <- cut(lab$logrevenue, breaks = seq(floor(min(lab$logrevenue)),
ceiling(max(lab$logrevenue)), by = 0.5), include.lowest = TRUE, right = FALSE)
# Crear etiquetas para los intervalos con el formato logarítmico y su equivalente en la escala original
# Usamos 'paste0' para crear etiquetas que incluyan ambas escalas.
lab$revenue_intervalos_etiquetas <- sapply(levels(lab$revenue_cat_log), function(x) {
rango_log <- as.numeric(gsub("[^0-9.-]", "", unlist(strsplit(x, ","))))
paste0("log10([", round(10^rango_log[1], 0), ", ", round(10^rango_log[2], 0), ")) = ", x ,"")
})
# Reemplazar los niveles de 'copiesSold_intervalos_log' por las nuevas etiquetas
levels(lab$revenue_cat_log) <- lab$revenue_intervalos_etiquetas
price_cat <- cut(lab$price, breaks = seq(0, 100, by = 5), right = FALSE)  # 4 intervalos para y
# Tabla de frecuencias absolutas
tabla_abs_priceRevenue <- table(lab$revenue_cat_log, price_cat)
# Frecuencias relativas (porcentajes)
tabla_rel_priceRevenue <- prop.table(tabla_abs_priceRevenue) * 100
# Crear tabla combinada con frecuencias absolutas y relativas
tabla_contingencia_priceRevenue <- matrix(paste(tabla_abs_priceRevenue, "(", round(tabla_rel_priceRevenue, 2), "%)", sep = ""),
nrow = nrow(tabla_abs_priceRevenue), ncol = ncol(tabla_abs_priceRevenue))
# Asignar nombres a filas y columnas
rownames(tabla_contingencia_priceRevenue) <- rownames(tabla_abs_priceRevenue)
colnames(tabla_contingencia_priceRevenue) <- colnames(tabla_abs_priceRevenue)
# Mostrar la tabla combinada
kable(tabla_contingencia_priceRevenue)
lab |>
ggplot(aes(x = logrevenue, y = price)) +
geom_point() +
geom_smooth() +
labs(title = "Gráfico de dispersión con ajuste de regresión")
lab |>
ggplot(aes(x = logrevenue, y = price)) +
geom_point() +
geom_smooth(method = lm, se = FALSE) +
labs(title = "Gráfico de dispersión con ajuste de regresión lineal")
summary(lab |> select(logrevenue, price) |> with(lm(logrevenue ~ price)))
# Calcular la correlación entre avgPlayTime y revenue
correlacion <- cor(lab$avgPlaytime, lab$revenue, use = "complete.obs")
# Crear un dataframe para mostrar la correlación en formato de tabla
correlacion_df <- data.frame(Variable1 = "avgPlaytime",
Variable2 = "revenue",
Correlacion = round(correlacion, 2))
# Mostrar la tabla con kable
correlacion_df %>%
kable(caption = "Correlación entre el tiempo de juego medio y la recaudación") %>%
kable_styling(full_width = F)
lab |>
ggplot(aes(x = avgPlaytime, y = revenue)) +
# Añadir puntos
geom_point(alpha = 0.7, color = "blue") +
# Usar escala logarítmica en el eje Y (revenue)
scale_y_log10() +
# Ajustar los límites del eje X para mejorar la visualización
xlim(0, 300) +
# Añadir etiquetas y un título más descriptivo
labs(
x = "Tiempo promedio de juego (horas)",
y = "Recaudación (log scale)",
title = "Relación entre Tiempo de Juego y Recaudación en Steam"
) +
# Mejorar el tema visual
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
axis.title.x = element_text(face = "bold"),
axis.title.y = element_text(face = "bold")
)
modelo <- lm(lab$revenue ~ lab$avgPlaytime)
summary(modelo)  # Resumen del modelo de regresión
# Crea una tabla de contingencia absoluta entre las variables 'analista' y 'tipo' y la muestra en formato Markdown
kable(table(lab$analista, lab$tipo))
# Crea una tabla de contingencia relativa (frecuencias relativas) para las mismas variables y la muestra con dos decimales
kable(prop.table(table(lab$analista, lab$tipo)), digits = 2)
# Crea una tabla de contingencia usando la función 'ctable' del paquete 'summarytools'.
tabla_contingencia <- summarytools::ctable(lab$tipo, lab$analista)
# 'summarytools::ctable' es una función del paquete 'summarytools' que se utiliza para crear tablas de contingencia.
# 'lab$tipo' y 'lab$analista' son las dos variables del dataframe 'lab' que se están comparando.
# La tabla de contingencia resultante mostrará la frecuencia de cada combinación de 'tipo' y 'analista'.
# Selecciona la primera tabla de la lista 'tabla_contingencia', la convierte en un tibble y filtra por 'analista_13'.
tabla_contingencia[[1]] |>
# 'as_tibble()' convierte la tabla (que probablemente sea una matriz o dataframe) en un tibble, que es un tipo de dataframe moderno en R.
as_tibble() |>
# 'filter(analista == 'analista_13')' filtra las filas donde la columna 'analista' es igual a 'analista_13'.
filter(analista == 'analista_13')
# Selecciona la primera tabla de la lista 'tabla_contingencia', la convierte en un tibble y filtra por 'tipo == 'A''.
tabla_contingencia[[1]] |>
# 'as_tibble()' convierte la tabla en un tibble.
as_tibble() |>
# 'filter(tipo == 'A')' filtra las filas donde la columna 'tipo' es igual a 'A'.
filter(tipo == 'A')
# Genera histogramas para las variables 'ph' y 'est' sin mostrar los gráficos, para determinar los intervalos de clase
histo <- hist(lab$ph, plot = FALSE)
histo2 <- hist(lab$est, plot = FALSE, breaks = 4)
# Clasifica las variables 'ph' y 'est' en categorías basadas en los intervalos anteriores y añade estas categorías al dataframe
lab <- lab |>
mutate(clase_ph = cut(ph, breaks = histo$breaks)) |>
mutate(clase_est = cut(est, breaks = histo2$breaks))
# Ajusta manualmente los niveles de la variable 'clase_ph' para incluir un intervalo específico
levels(lab$clase_ph) <- c(levels(lab$clase_ph), "(6.4,6.45]")
# Crea una tabla de contingencia entre las categorías de 'ph' y 'est', añadiendo totales con addmargins(), y la muestra
tabla <- table(lab$clase_ph, lab$clase_est) |> addmargins()
tabla |> kable()
lab |> select(where(is.numeric), -codigo) |>  # Selecciona solo las variables numéricas, excluyendo 'codigo'
drop_na() |>  # Elimina filas con valores NA
cov() |>  # Calcula la matriz de covarianzas
round(2)  # Redondea los resultados a 2 decimales
lab |> select(where(is.numeric), -codigo) |>  # Selecciona solo las variables numéricas, excluyendo 'codigo'
drop_na() |>  # Elimina filas con valores NA
cor() |>  # Calcula la matriz de correlación
round(2)  # Redondea los resultados a 2 decimales
# 'lab |> select(where(is.numeric), -codigo)' selecciona las columnas numéricas del dataframe 'lab', excluyendo la columna 'codigo'.
lab |>
select(where(is.numeric), -codigo) |>
# 'drop_na()' elimina todas las filas que contienen valores NA (faltantes).
drop_na() |>
# 'cor()' calcula la matriz de correlación entre las columnas numéricas seleccionadas.
cor() |>
# 'round(2)' redondea los coeficientes de correlación a dos decimales.
round(2) |>
# 'corrplot()' visualiza la matriz de correlación.
corrplot(
method = "ellipse",  # 'method = "ellipse"' utiliza elipses para representar los coeficientes de correlación.
type = "lower",      # 'type = "lower"' muestra solo la mitad inferior de la matriz de correlación.
addCoef.col = "steelblue",  # 'addCoef.col = "steelblue"' establece el color de los coeficientes de correlación.
diag = FALSE         # 'diag = FALSE' omite la diagonal principal de la matriz, que siempre es 1.
)
# Gráficos de barras para frecuencias conjuntas
# Crea un gráfico de barras para las variables 'tipo' y 'analista' usando ggplot2
lab |> # Toma el dataframe 'lab'
ggplot(aes(x = tipo, fill = analista)) + # Inicializa ggplot2, asignando 'tipo' al eje x y coloreando por 'analista'
geom_bar() + # Añade un gráfico de barras, que por defecto cuenta la cantidad de cada 'tipo'
theme_bw() # Aplica un tema en blanco y negro para una visualización más clara y profesional
lab |> # Toma el dataframe 'lab'
ggplot(aes(x = tipo, fill = analista)) + # Inicializa ggplot2, asignando 'tipo' al eje x y coloreando por 'analista'
geom_bar(position = position_dodge()) + # Añade un gráfico de barras con barras separadas por 'analista' dentro de cada 'tipo'
theme_bw() # Aplica un tema en blanco y negro para una visualización más clara y profesional
# Crear un histograma de 'ph' con colores basados en 'tipo'
ggplot(lab, aes(x = ph, fill = tipo)) +
# Añadir la capa de histograma
geom_histogram(
bins = 15,
alpha = 0.7,  # Ajusta la transparencia para mejor visualización
position = 'identity'  # Superpone las barras
) +
# Definir los títulos de los ejes y el gráfico
labs(
title = "Histograma de pH por Tipo",
x = "pH",
y = "Frecuencia"
) +
# Aplicar un tema
theme_bw() +
# Añadir leyenda (automáticamente generada por ggplot)
guides(fill=guide_legend(title="Tipo"))
# Gráfico de dispersión
# Crea un gráfico de dispersión para las variables 'est' y 'ph'
lab |>
# 'ggplot()' inicia una gráfica utilizando el paquete ggplot2. 'aes()' define las estéticas del gráfico, asignando 'est' al eje x y 'mg' al eje y.
ggplot(aes(x = est, y = mg)) +
# 'geom_point()' añade capas de puntos al gráfico, lo que crea un gráfico de dispersión con puntos representando las combinaciones de 'est' y 'mg'.
geom_point()
# Gráfico de dispersión
# Crea un gráfico de dispersión para las variables 'est' y 'mg'
lab |>
# 'ggplot()' inicia una gráfica utilizando el paquete ggplot2. 'aes()' define las estéticas del gráfico, asignando 'est' al eje x y 'mg' al eje y.
ggplot(aes(x = est, y = mg)) +
# 'geom_point()' añade capas de puntos al gráfico, lo que crea un gráfico de dispersión con puntos representando las combinaciones de 'est' y 'mg'.
geom_point() +
# 'geom_smooth()' añade una línea de tendencia o ajuste al gráfico. Por defecto, realiza un ajuste de regresión lineal que muestra la tendencia general entre 'est' y 'mg'.
geom_smooth(method = lm) +
# 'labs()' permite personalizar las etiquetas del gráfico, como el título. Aquí se establece el título del gráfico.
labs(title = "Gráfico de dispersión con ajuste de regresión")
# Gráfico de dispersión
# Crea un gráfico de dispersión para las variables 'est' y 'ph'
lab |>
# 'ggplot()' inicia una gráfica utilizando el paquete ggplot2. 'aes()' define las estéticas del gráfico, asignando 'est' al eje x y 'mg' al eje y.  Además, la estética 'col' se usa para colorear los puntos según el valor de la variable 'tipo'.
ggplot(aes(x = est, y = mg, col = tipo)) +
# 'geom_point()' añade capas de puntos al gráfico, lo que crea un gráfico de dispersión con puntos representando las combinaciones de 'est' y 'mg'.
geom_point() +
# 'geom_smooth()' añade una línea de tendencia o ajuste al gráfico. Realiza un ajuste de regresión lineal que muestra la tendencia general entre 'est' y 'mg', para cada valor de la varaible tipo.
geom_smooth(method = lm) +
# 'labs()' permite personalizar las etiquetas del gráfico, como el título. Aquí se establece el título del gráfico.
labs(title = "Gráfico de dispersión con ajuste de regresión")
# Gráficos de cajas por grupos
lab |>
ggplot(aes(x = tipo, y = ph)) +  # Define las variables para el eje x ('tipo') y el eje y ('ph')
geom_boxplot() +  # Crea un gráfico de cajas
theme_bw() +  # Utiliza un tema en blanco y negro para el gráfico
labs(title = "pH por tipo de queso")  # Añade un título al gráfico
# Gráficos de cajas por grupos eje y color
lab |>
ggplot(aes(x = analista, y = ph)) +  # Establece 'analista' en el eje x y 'ph' en el eje y
geom_boxplot() +  # Genera el gráfico de cajas
geom_jitter(aes(col = tipo), alpha = 0.2) +  # Añade puntos individuales para mostrar la distribución, con color por 'tipo'
theme_bw() +  # Aplica un tema en blanco y negro
labs(title = "pH por analista")  # Asigna un título al gráfico
# 'ggpairs()' es una función del paquete GGally que crea pares de gráficos para cada combinación de variables.
ggpairs(
# 'lab |> select(ph, est, mg, sal, tipo)' selecciona las columnas específicas 'ph', 'est', 'mg', 'sal' y 'tipo' del dataframe 'lab'.
lab |> select(ph, est, mg, sal, tipo),
# 'aes(col = tipo)' define las estéticas para el gráfico, en este caso, asignando diferentes colores a cada valor de 'tipo'.
aes(col = tipo)
)
lab |>  select(where(is.numeric), -codigo) |>   # Selecciona todas las columnas numéricas menos el código
drop_na() |>  # Elimina las filas con valores NA
summarise(across(everything(), mean))  # Calcula la media para las columnas seleccionadas
# Resumen numérico de una variable continua para cada categoría de otra discreta
# 'with(lab, stby(mg, tipo, descr))' aplica una función a un subconjunto de datos dentro del dataframe 'lab'.
with(
# 'lab' es el dataframe que contiene los datos.
lab,
# 'stby()' es una función que aplica otra función ('descr' en este caso) a subconjuntos de datos.
# Aquí se aplica 'descr' a la variable 'mg', agrupada por los valores de 'tipo'.
stby(
# 'mg' es la variable a la que se le aplicará la función 'descr'.
mg,
# 'tipo' es la variable de agrupación. 'descr' se aplicará por separado a los grupos definidos por 'tipo'.
tipo,
# 'descr' es la función que se aplica. Calcula estadísticas descriptivas para 'mg' dentro de cada grupo de 'tipo'.
descr
)
)
# Recta de refresión de la variable 'est' en función de 'mg'
lab |>
slice(1:15) |>  # Selecciona los primeros 15 registros
select(mg, est) |>  # Selecciona las columnas 'mg' y 'est'
ggplot(aes(x=mg, y = est)) +  # Define las variables para el gráfico
geom_point() +  # Añade puntos al gráfico
theme_bw() +  # Aplica un tema en blanco y negro
geom_smooth(method = lm, se = FALSE)  # Añade una línea de regresión lineal sin intervalo de confianza
# Creación y resumen de un modelo lineal para 'est' en función de 'mg'
mod <- lab |>
slice(1:15) |>  # Selecciona los primeros 15 registros
select(mg, est) |>  # Selecciona las variables 'mg' y 'est'
with(lm(est ~ mg))  # Crea un modelo lineal de 'est' en función de 'mg'
# Muestra un resumen del modelo lineal
# Esto incluye estadísticas como el R-cuadrado, los coeficientes del modelo, sus errores estándar, valores t y p-valores.
# Es útil para evaluar la calidad del ajuste y la significancia de las variables.
summary(mod)
# Recta de refresión de la variable 'est' en función de 'mg' filtrando por tipo 'C'
lab |>
# 'filter(tipo == "C")' filtra el dataframe para incluir solo las filas donde la columna 'tipo' es igual a "C".
filter(tipo == "C") |>
# 'ggplot(aes(x = mg, y = est))' inicia la creación de un gráfico ggplot2, definiendo 'mg' como la variable del eje x y 'est' como la del eje y.
ggplot(aes(x = mg, y = est)) +
# 'geom_point()' añade una capa de puntos al gráfico, mostrando la relación entre 'mg' y 'est' para las observaciones donde 'tipo' es "C".
geom_point() +
# 'geom_smooth(method = "lm")' añade una línea de ajuste lineal al gráfico. 'method = "lm"' indica que se usa un modelo lineal para el ajuste.
geom_smooth(method = "lm")
# 'modelo <- lm(est ~ mg, data = lab, subset = tipo == "C")' crea un modelo lineal.
modelo <- lm(
# 'est ~ mg' define la fórmula del modelo, donde 'est' es la variable dependiente y 'mg' la variable independiente.
est ~ mg,
# 'data = lab' especifica que los datos para el modelo provienen del dataframe 'lab'.
data = lab,
# 'subset = tipo == "C"' restringe el análisis a las filas del dataframe donde 'tipo' es igual a "C".
subset = tipo == "C"
)
# 'summary(modelo)' proporciona un resumen del modelo lineal ajustado.
# Esto incluye estadísticas como el R-cuadrado, los coeficientes del modelo, sus errores estándar, valores t y p-valores.
# Es útil para evaluar la calidad del ajuste y la significancia de las variables.
summary(modelo)
###Estudio de las variables COPIESSOLD Y REVENUE
Antes de comenzar con el analisis bivariante de "copiesSold" y "revenue" vamos a hacer un resumen de ambas variables para saber la cantidad de copias vendidas y la recaudación promedio, los valores mínimos y máximos, o los valores faltantes en caso de que los haya. Esto se hace con el objetivo de conocer mejor sus valores y distribución.
#Comprobamos que no falte ningún dato
sum(is.na(lab$copiesSold))
sum(is.na(lab$revenue))
#Realizamos el resumen de ambas variables
summary(lab$copiesSold)
summary(lab$revenue)
ggplot(lab, aes(x = copiesSold, y = revenue)) +
geom_jitter(color = "blue", size = 1, width = 0.2, height = 0, alpha = 0.7) +
scale_y_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),
format(x)))
}) +
scale_x_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),
format(x)))
}) +
labs(title = "Relación entre Copias Vendidas y Recaudación",
x = "Copias Vendidas",
y = "Recaudación (en logaritmos)") +
theme_minimal()
correlacion <- cor(lab$copiesSold, lab$revenue, use = "complete.obs")
correlacion_df <- data.frame(Variable1 = "copiesSold",
Variable2 = "revenue",
Correlacion = round(correlacion, 2))
correlacion_df %>%
kable(caption = "Correlación entre las copias vendidas y la recaudación") %>%
kable_styling(full_width = F)
# Ajustar un modelo de regresión lineal
modelo <- lm(revenue ~ copiesSold, data = lab)
# Resumen del modelo
summary(modelo)
ggplot(lab, aes(x = copiesSold, y = revenue)) +
geom_point(size = 2, alpha = 0.7) +  # Puntos del gráfico
geom_smooth(method = "lm", color = "blue") +  # Línea de regresión
scale_x_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),  # Formato en millones
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),  # Formato en miles
format(x)))  # Menos de mil
}) +
scale_y_continuous(labels = function(x) {
ifelse(x >= 1e6,
paste0(format(x / 1e6, big.mark = ",", digits = 2), " M"),  # Formato en millones
ifelse(x >= 1e3,
paste0(format(x / 1e3, big.mark = ",", digits = 2), " K"),  # Formato en miles
format(x)))  # Menos de mil
}) +
labs(title = "Regresión Lineal: Copias Vendidas vs Recaudación",
x = "Copias Vendidas",
y = "Recaudación (en miles de dólares)") +
theme_minimal()
